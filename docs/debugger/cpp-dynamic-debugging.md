---
title: C++ Dynamic Debugging (Preview)
description: Learn how to use C++ Dynamic Debugging to easily debug optimized code.
ms.date: 03/11/2025
ms.topic: how-to
f1_keywords: 
  - vs.debug
dev_langs: 
  - C++
helpviewer_keywords: 
  - breakpoints, in optimized code
  - debugging [C++], optimized code
  - optimization, debug builds
  - optimized code, debugging
author: tylerMSFT
ms.author: twhitney
manager: coxford
ms.subservice: debug-diagnostics
---
# C++ Dynamic Debugging (Preview)
> [!IMPORTANT]
> C++ Dynamic Debugging is currently in PREVIEW.
> This information relates to a prerelease feature that might be substantially modified before release. Microsoft makes no warranties, expressed or implied, with respect to the information provided here.

This preview feature, available starting with Visual Studio 2022 Version 17.14 Preview 2, applies only to x64 projects.

C++ Dynamic Debugging enables you to debug optimized code as if it were unoptimized. This feature is useful for developers who require the performance benefits of optimized code, such as game developers who need high frame rates. With C++ Dynamic Debugging, you can enjoy the debugging experience of unoptimized code without sacrificing the performance advantages of optimized builds.

Debugging optimized code presents challenges. The compiler optimizes code by repositioning and reorganizing instructions, resulting in more efficient code. However, this means:

- The optimizer can remove local variables or move them to locations unknown to the debugger.
- Code inside a function may no longer align with source code when the optimizer merges blocks of code.
- Function names for functions on the call stack might be wrong if the optimizer merges two functions.

In the past, developers dealt with these and other problems when debugging optimized code. C++ Dynamic Debugging does away with these challenges by allowing you to step into optimized code as if it were unoptimized.

In addition to generating the optimized binaries, compiling with [`/dynamicdeopt`](/cpp/build/reference/dynamic-deopt) generates unoptimized binaries used during debugging. When you add a breakpoint, or step into a function, the debugger loads the unoptimized binary and you debug the unoptimized code for the function instead of the optimized code. This allows you to debug as if you're debugging unoptimized code while still getting the performance advantages of optimized code in the rest of the program.

## Try out C++ Dynamic Debugging

First, let's review what it's like to debug optimized code, and then we'll see how C++ Dynamic Debugging simplifies the process.

1. Create a new C++ console application project in Visual Studio and replacing the contents of the `ConsoleApplication.cpp` file with the following code:

```cpp
// Code generated by GitHub Copilot
#include <iostream>
#include <chrono>
#include <thread>

using namespace std;

int step = 0;
const int rows = 20;
const int cols = 40;

void printGrid(int grid[rows][cols])
{
    cout << "Step: " << step << endl;
    for (int i = 0; i < rows; ++i)
    {
        for (int j = 0; j < cols; ++j)
        {
            cout << (grid[i][j] ? '*' : ' ');
        }
        cout << endl;
    }
}

int countNeighbors(int grid[rows][cols], int x, int y)
{
    int count = 0;
    for (int i = -1; i <= 1; ++i)
    {
        for (int j = -1; j <= 1; ++j)
        {
            if (i == 0 && j == 0)
            {
                continue;
            }

            int ni = x + i;
            int nj = y + j;
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols)
            {
                count += grid[ni][nj];
            }
        }
    }
    return count;
}

void updateGrid(int grid[rows][cols])
{
    int newGrid[rows][cols] = { 0 };
    for (int i = 0; i < rows; ++i)
    {
        for (int j = 0; j < cols; ++j)
        {
            int neighbors = countNeighbors(grid, i, j);
            if (grid[i][j] == 1)
            {
                newGrid[i][j] = (neighbors < 2 || neighbors > 3) ? 0 : 1;
            }
            else
            {
                newGrid[i][j] = (neighbors == 3) ? 1 : 0;
            }
        }
    }
    // Copy newGrid back to grid
    for (int i = 0; i < rows; ++i)
    {
        for (int j = 0; j < cols; ++j)
        {
            grid[i][j] = newGrid[i][j];
        }
    }
}

int main()
{
    int grid[rows][cols] = { 0 };

    // Initial configuration (a simple glider)
    grid[1][2] = 1;
    grid[2][3] = 1;
    grid[3][1] = 1;
    grid[3][2] = 1;
    grid[3][3] = 1;

    while (true)
    {
        printGrid(grid);
        updateGrid(grid);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        cout << "\033[H\033[J"; // Clear the screen
        step++;
    }

    return 0;
}
```

2. Change the **Solution Configurations** dropdown to `Release`. Ensure the solutions platform dropdown is set to `x64`.
3. Rebuild by selecting **Build** > **Rebuild Solution**
4. Set a breakpoint on line 55, `int neighbors = countNeighbors(grid, i, j);` in `updateGrid()`. Run the program.
5. When you hit the breakpoint, view the **Locals** window by selecting from the main menu: **Debug** > **Windows** > **Locals**. Notice that you can't see the value of `i` or `j` in the **Locals** window. The compiler has optimized them away.
6. Try to set a breakpoint on line 19, `cout << (grid[i][j] ? '*' : ' ');` in `printGrid()`. You can't. This is expected because the compiler has optimized the code.

**Stop the program and enable C++ Dynamic Debugging and try it again:**

7. In **Solution Explorer**, right-click the project and select **Properties** to open the project property pages.
8. Choose **Advanced** > **Use C++ Dynamic Debugging** and set it to **Yes**:

    :::image type="complex" source="media/vs-2022/property-use-cpp-debugging.png" alt-text="A screenshot of the project properties.":::
    The property page is opened to Configuration Properties > Advanced > Use C++ Dynamic Debugging. The property is set to Yes.
    :::image-end:::

    This adds the `/dynamicdeopt` switch to the compiler and to the linker. Behind the scenes, it also turns off the C++ optimization switches `/GL` and `/OPT:ICF`. This setting doesn't overwrite switches you've added manually to the command line or other optimization switches that are set such as `/O1`.

9. Rebuild with **Build** > **Rebuild Solution**. Build diagnostic code [`MSB8088`](../msbuild/errors/msb8088.md) appears indicating that dynamic debugging and whole program optimization are incompatible. This means that whole program optimization (`/GL`) was automatically turned off during compilation. You can manually turn off whole program optimization in the project properties by setting **Configuration Properties** > **Advanced** > **Whole Program Optimization** to **Off**. `MSB8088` is treated as a warning, but may be treated as an error in a future version of Visual Studio.

10. Rerun the app.

    Now when you hit the breakpoint on line 55, you see the values of `i` and `j` in the locals window. The **Call Stack** window shows that `updateGrid()` is deoptimized and the filename is `life.alt.exe`. That's the alternate binary used to debug optimized code:

    :::image type="complex" source="media/vs-2022/dbg-deopt-update-grid-callstack.png" alt-text="A screenshot of debugging the updateGrid function.":::
    A breakpoint is shown in the function updateGrid. The call stack shows that the function is deoptimized and the filename is life.alt.exe. The locals window shows the values of i and j, and the other local variables in the function.
    :::image-end:::

    The `updateGrid()` function is deoptimized on demand because you set a breakpoint in it. If you step over an optimized function while debugging, it isn't deoptimized. If you step *into* a function, it's deoptimized. The main way to cause a function to be deoptimized is by setting a breakpoint in it or stepping into it.

    You can also deoptimize a function in the **Call Stack** window by right-clicking the function, or a selected group of functions, and selecting **Deoptimize on next entry**. This is useful when you want to view local variables in an optimized function that you haven't set a breakpoint in elsewhere on the callstack. Functions deoptimized in this way are grouped together in the **Breakpoints** window as a breakpoint group named **Deoptimized Functions**. Deleting the breakpoint group reverts the associated functions to their optimized state.

    **Conditional and dependent breakpoints work too!**

11. Try setting a breakpoint again on line 19, `cout << (grid[i][j] ? '*' : ' ');` in `printGrid()`. This works now. That's because setting a breakpoint in the function deoptimizes it so that you can debug it normally.
12. Right-click the breakpoint on line 19, choose **Conditions...**, and set the condition to `i == 10 && j== 10`. Then select **Only enable when the following breakpoint is hit:** and select the breakpoint on line 55 from the drop-down. Now the breakpoint on line 19 doesn't hit until the breakpoint on line 50 is first hit, and then when `grid[10][10]` is about to output to the console. The point is that you can set conditional and dependent breakpoints in an optimized function and make use of local variables and lines of code that in an optimized build may be unavailable to the debugger.

    :::image type="complex" source="media/vs-2022/dbg-deopt-conditional-breakpoint.png" alt-text="A screenshot of the conditional breakpoint settings for line 19.":::
    A conditional breakpoint is shown on line 19, cout < < (grid[i][j] ? '*' : ' '); The condition is set to i == 10 && j== 10. The checkbox for Only enable when the following breakpoint is hit is selected. The breakpoint dropdown is set to life.cpp line 55.
    :::image-end:::

13. Continue running the app. When the breakpoint on line 19 is hit, you can even right click on line 15 and choose **Set Next Statement** to rerun the loop again.

    :::image type="complex" source="media/vs-2022/dbg-deopt-conditional-breakpoint-hit.png" alt-text="A screenshot of debugging the printGrid function.":::
    A conditional and dependent breakpoint is hit on line 19, out < < (grid[i][j] ? '*' : ' '); The Locals window shows the values of i and j, and the other local variables in the function. The Call Stack window shows that the function is deoptimized and the filename is life.alt.exe.
    :::image-end:::

14. Delete all the breakpoints to return deoptimized functions to their optimized state. From the Visual Studio main menu, choose **Debug** > **Delete All Breakpoints**. All functions return to their optimized state. If you add breakpoints via the **Call Stack** window **Deoptimize on next entry** option, which we didn't do in this walkthrough, you could right-click the **Deoptimized Functions** group and select **Delete** to revert only the functions in that group back to their optimized state:

    :::image type="complex" source="media/vs-2022/dbg-deopt-delete-breakpoints.png" alt-text="A screenshot of the Breakpoints window.":::
    The Breakpoints window shows the Deoptimized Functions group. The group is selected and the context menu is open with Delete Breakpoint Group selected.
    :::image-end:::

## Turn off C++ Dynamic Debugging

You may need to debug optimized code without it being deoptimized, or put a breakpoint in optimized code and have the code stay optimized when the breakpoint hits. There are several ways to turn off Dynamic Debugging or keep it from deoptimizing code when you hit a breakpoint:

- From the Visual Studio main menu: **Tools** > **Options** > **Debugging** > **General**, uncheck **Automatically deoptimize debugged functions when possible (.NET 8+, C++ Dynamic Debugging)**. The next time the debugger starts, code remains optimized.
- Many dynamic debugging breakpoints are two breakpoints: one in the optimized binary and one in the unoptimized binary. In the **Breakpoints** window, choose **Show Columns** > **Function**, and deselect the breakpoint that belongs to the the `alt` binary. The other breakpoint in the pair breaks in the optimized code.
- While debugging, from the Visual Studio main menu choose **Debug** > **Windows** > **Dissassembly** and ensure it has focus. When you step-into a function via the disassembly window, the function won't be deoptimized.
- Disable dynamic debugging entirely by not passing `/dynamicdeopt` to `cl.exe`, `lib.exe`, and `link.exe`. If you're consuming third party libraries and can't rebuild them, don't pass `/dynamicdeopt` during the final `link.exe` to disable Dynamic Debugging for that binary.
- To quickly disable dynamic debugging for a single binary (for example, `test.dll`), rename or delete the `alt` binary (for example, `test.alt.dll`).
- To disable Dynamic Debugging for one or more `.cpp` files, don't pass `/dynamicdeopt` when building them. The remainder of your project is built with dynamic debugging.

## Enable C++ Dynamic Debugging in Unreal Engine

Unreal Engine 5.6 supports C++ Dynamic Debugging for both Unreal Build Tool and Unreal Build Accelerator. There are two ways to enable it:

- Use the **Development Editor** configuration, and modify your `BuildConfiguration.xml` to include:
    ```xml
    <WindowsPlatform>
        <bDynamicDebugging>true</bDynamicDebugging>
    </WindowsPlatform>
    ```
- Another way is modify your `Target.cs` file for your project to contain `WindowsPlatform.bDynamicDebugging = true`.

For more information, see the Unreal Engine article [Build Configuration](https://dev.epicgames.com/documentation/en-us/unreal-engine/build-configuration-for-unreal-engine).

## Troubleshooting

If breakpoints don't hit in [Deoptimized] frames:
- Ensure that the `alt.exe` and `alt.pdb` files built. Given `test.exe` and `test.pdb`, `test.alt.exe` and `test.alt.pdb` must exist in the same directory. Ensure that the right build switches are set per this guide.
- A "debug directory" entry exists in `test.exe` that tells the debugger the name of the `alt` binary to use for Deoptimized Debugging. Open a x64-native Visual Studio command prompt and run: `link /dump /headers <your executable.exe>` to see if a `deopt` entry exists. A `deopt` entry appears in the `Type` column as shown in the last line this example:

    ```Output
      Debug Directories
    
            Time Type        Size      RVA  Pointer
        -------- ------- -------- -------- --------
        67CF0DA2 cv            30 00076330    75330    Format: RSDS, {7290497A-E223-4DF6-9D61-2D7F2C9F54A0}, 58, D:\work\shadow\test.pdb
        67CF0DA2 feat          14 00076360    75360    Counts: Pre-VC++ 11.00=0, C/C++=205, /GS=205, /sdl=0, guardN=204
        67CF0DA2 coffgrp      36C 00076374    75374
        67CF0DA2 deopt         22 00076708    75708    Timestamp: 0x67cf0da2, size: 532480, name: test.alt.exe
    ```

    If the `deopt` debug directory entry isn't there, confirm that you're passing `/dynamicdeopt` to `cl.exe`, `lib.exe`, and `link.exe`.    

- When `/dynamicdeopt` isn't passed to `cl.exe`, `lib.exe`, and `link.exe`, for all `.cpp`, `.lib`, and binary files, Dynamic Deoptimization doesn't work well. Confirm that the proper switches are set while running all C/C++ build tools.
- See our list of known issues:
  - JTW

If you don't see what you need, or things aren't working as expected, open a ticket at [Developer Community](https://developercommunity.visualstudio.com/cpp), containing as much information as possible about the issue.

## General notes

IncrediBuild 10.23 supports C++ Dynamic Debugging builds.

Functions that are inlined are deoptimized on demand. If you set a breakpoint on an inlined function, the debugger deoptimizes the function and its caller. The breakpoint hits where you expect it to, as if your program was built without compiler optimizations.

A function remains deoptimized even if you disable the breakpoints within it. You must remove the breakpoint for the function to revert to its optimized state.

Many dynamic debugging breakpoints are two breakpoints: one in the optimized binary and one in the unoptimized binary. This is why you see more than one breakpoint in the **Breakpoints** window.

The compiler flags used for the deoptimized version are the same as the flags used for the optimized version--except for optimization flags and `/dynamicdeopt`. This means any flags you set to define macros, and so on, are set in the deoptimized version as well. However, deoptimized code isn't the same as debug code. The deoptimized code is compiled with the same optimization flags as the optimized version, so asserts and other code that rely on debug-specific settings aren't included.

## Build system integration

C++ Dynamic Debugging requires that compiler and linker flags be set a particular way. The following sections describe how to setup a dedicated configuration for Dynamic Debugging that doesn't have conflicting switches.

If your project is built with the Visual Studio build system, a good way to make a Dynamic Debugging configuration is to use the Configuration Manager to clone your Release or Debug configuration and make changes to accomodate Dynamic Debugging as described in the following two sections:

### How to create a new Release configuration

1. From the Visual Studio main menu, open the configuration manager via **Build** > **Configuration Manager**.
1. Choose the Configuration dropdown and then **<New...>**.

    :::image type="complex" source="media/vs-2022/dbg-clone-configuration.png" alt-text="A screenshot of the Configuration Manager.":::
    In the Configuration Manager, under Project contexts, the Configuration dropdown is open and <New...> is highlighted.
    :::image-end:::

1. The **New Solution Configuration** dialog box opens. In the **Name** field, enter a name for the new configuration, such as `ReleaseDD`. Ensure that **Copy settings from:** is set to **Release**, then choose **OK** to create the new configuration:

    :::image type="complex" source="media/vs-2022/dbg-clone-configuration-details-release.png" alt-text="A screenshot of the New Project Configuration dialog box.":::
    The name field is set to ReleaseDD. The copy settings from dropdown is set to Release.
    :::image-end:::

1. The new configuration appears in the **Active solution configuration** drop-down list. Choose **Close**.
1. With the Configuration dropdown set to **ReleaseDD**, right-click your project in the **Solution Explorer** and choose **Properties**.
1. In **Configuration Properties** > **Advanced**, set **Use C++ Dynamic Debugging** to **Yes**.
1. Ensure that **Whole Program Optimization** is set to **No**.

    :::image type="complex" source="media/vs-2022/property-use-cpp-debugging.png" alt-text="A screenshot of the project properties.":::
    The property page is opened to Configuration Properties > Advanced > Use C++ Dynamic Debugging. The property is set to Yes.
    :::image-end:::

1. Ensure that **Configuration Properties** > **Linker** > **Optimization** > **Enable Incremental Linking** is set to **No (/OPT:NOICF)**.

    :::image type="complex" source="media/vs-2022/property-incremental-linking.png" alt-text="A screenshot of the project properties.":::
    The property page is opened to Configuration Properties > Linker > Optimization > Enable Incremental Linking. The property is set to No.
    :::image-end:::

This adds the `/dynamicdeopt` switch to the compiler and to the linker. With C++ optimization switches `/GL` and `/OPT:ICF` also turned off, you can now build and run your project in the new configuration when you want an optimized release build that you can use with C++ dynamic debugging. You can add other switches you use with your retail builds to this configuration so that you always have exactly the switches on/off that you expect when you use Dynamic Debugging. For more information about switches you shouldn't use with Dynamic Debugging, see [Incompatible options](#incompatible-options).

For more information about configurations in Visual Studio, see [Create and edit configurations](/visualstudio/ide/how-to-create-and-edit-configurations).

### How to make a new Debug configuration

If you want to use debug binaries, but want them to run faster, you can modify your Debug configuration as follows:

1. From the Visual Studio main menu, open the configuration manager with **Build** > **Configuration Manager**.
1. Choose the Configuration dropdown and then **<New...>**.

    :::image type="complex" source="media/vs-2022/dbg-clone-configuration.png" alt-text="A screenshot of the Configuration Manager.":::
    In the Configuration Manager, in the Project contexts part of the window, the Configuration dropdown is open and <New...> is highlighted.
    :::image-end:::

1. The **New Solution Configuration** dialog box opens. In the **Name** field, enter a name for the new configuration, such as `DebugDD`. Ensure that **Copy settings from:** is set to **Debug**, then choose **OK** to create the new configuration

    :::image type="complex" source="media/vs-2022/dbg-clone-configuration-details-debug.png" alt-text="A screenshot of the New Project Configuration dialog box.":::
    The name field is set to DebugDD. The copy settings from dropdown is set to Debug.
    :::image-end:::

1. The new configuration appears in the **Active solution configuration** drop-down list. Choose **Close**.
1. With the Configuration dropdown set to **DebugDD**, right-click your project in the **Solution Explorer** and choose **Properties**.
1. In **Configuration Properties** >> **C/C++** >> **Optimization**, turn on the optimizations you want. For example, you could set **Optimization** to **Maximize Speed (/O2)**.
1. In **C/C++** >> **Code Generation**,  set **Basic Runtime Checks** to **Default**.
1. In **C/C++** >> **General**, disable **Support Just My Code Debugging**.
1. Set **Debug Information Format** to **Program Database (/Zi)**.

You can add other switches you use with your debug builds to this configuration so that you always have exactly the switches on/off that you expect when you use Dynamic Debugging. For more information about switches you shouldn't use with Dynamic Debugging, see [Incompatible options](#incompatible-options).

For more information about configurations in Visual Studio, see [Create and edit configurations](/visualstudio/ide/how-to-create-and-edit-configurations).

### Custom build system considerations

If you have a custom build system, ensure that you:
- Pass `/dynamicdeopt` to `cl.exe`, `lib.exe`, and `link.exe`.
- Don't use [`/ZI`](/cpp/build/reference/z7-zi-zi-debug-information-format), any of the [`/RTC`](/cpp/build/reference/rtc-run-time-error-checks) flags, or [`/JMC`](/cpp/build/reference/jmc).

For build distributors:

- Given a project named `test`, the compiler produces: `test.alt.obj`, `test.alt.exp`, `test.obj`, and `test.exp`. The linker produces `test.alt.exe`, `test.alt.pdb`, `test.exe`, and `test.pdb`.
- `c2dd.dll` is a new toolset binary that you need to deploy alongside `c2.dll`.

## Incompatible options

Some compiler and linker options are incompatible with C++ Dynamic Debugging. If you turn on C++ Dynamic Debugging using the Visual Studio project settings, incompatible options are automatically turned off unless you have specifically set them in the additional command-line options setting.

The following compiler options are incompatible with C++ Dynamic Debugging:

```cpp
/GH
/GL
/Gh
/RTC1 
/RTCc 
/RTCs 
/RTCu 
/ZI (/Zi is OK)
/ZW 
/clr 
/clr:initialAppDomain
/clr:netcore
/clr:newSyntax
/clr:noAssembly
/clr:pure
/clr:safe
/fastcap
/fsanitize=address
/fsanitize=kernel-address
```

The following linker options are incompatible with C++ Dynamic Debugging:

```cpp
/DEBUG:FASTLINK
/INCREMENTAL
/OPT:ICF  You can specify /OPT:ICF but the debugging experience may be poor
```

## Related content

[/dynamicdeopt compiler flag (Preview)](/cpp/build/reference/dynamic-deopt)\
[/DYNAMICDEOPT linker flag (Preview)](/cpp/build/reference/dynamic-deopt-linker)\
[Debug Optimized code](how-to-debug-optimized-code.md)